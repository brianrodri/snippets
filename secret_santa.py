#!/usr/bin/python3
"""
    secret_santa.py
    Brian Rodriguez <thatbrod@gmail.com>

        Auto-magic secret santa matcher! Given a list of participants and
    restrictions on their matches, the script will produce a collection of
    possible matches and (when commanded to) send an e-mail to these matches.
        This script is designed to be modified before getting run. It contains
    details necessary for a connection to some e-mail client, which will be the
    sender of e-mails generated by the script.
        To customize, go to @emaildb and @santdb and make changes accordingly.
    Follow their example to make changes you'd like to see.

        Run with -h/--help flag to see usage details
"""


import argparse
import collections
import itertools
import random
import smtplib
import sys


emaildb = {
    "Host": "smtp.gmail.com:587",
    "Username": "thatbrod",
    "Password": "********",

    "Subject": "Secret Santa 2015~",
    "Message": "HO HO HO! This year, you are {0}'s Secret Santa! The spending "
               "limit is $30, and we plan on exchanging gifts Christmas night! "
               "Have fun and stay sneaky!!"
#   note: instances of {0} will be replaced with the names of the Santees
}

santdb = [
    { "Name" : "Bavin", "E-Mail" : "bavin@word.zu" }, #idx 0
    { "Name" : "Binne", "E-Mail" : "binne@mint.zi" }, #idx 1
    { "Name" : "Bippo", "E-Mail" : "bippo@neat.za" }, #idx 2
    { "Name" : "Boogy", "E-Mail" : "boogy@whoa.zo" }, #idx 3
    { "Name" : "Brian", "E-Mail" : "brian@cool.ze" }, #idx 4
#   {                                              }, #idx ...
]

bad_pairs = {
    # ("Santa's IDX", "Santee's IDX"),
    (1, 4), (4, 0), (0, 3), (2, 1), (3, 0), (1, 2)
}


def bijections_of(elements, relations):
    mapping = collections.defaultdict(set)

    for lhs, rhs in relations:
        if elements >= {lhs, rhs}:
            mapping[lhs].add(rhs)

    if len(mapping.keys()) == len(elements):
        return [ list(zip(mapping.keys(), permutation))
            for permutation in itertools.product(*mapping.values())
            if len(set(permutation)) == len(elements) ]

    return None

def send_email(sa, se, server):
    sa, se = santdb[sa], santdb[se]
    server.sendmail(
        "santa@northpole.com",
        sa["E-Mail"],
        "\r\n".join(
            [
                "From: Santa <santa1@northpole.com>",
                "To: {} <{}>".format(sa["Name"], sa["E-Mail"]),
                "Subject: {}".format(emaildb["Subject"]),
                "",
                emaildb["Message"].format(se["Name"])
            ]
        )
    )

def main():
    parser = argparse.ArgumentParser()
    mut_exc = parser.add_mutually_exclusive_group()
    mut_exc.add_argument(
        "-s", "--send",
        help="send out emails to random pairs without printing",
        action="store_true"
    )
    mut_exc.add_argument(
        "-p", "--potentials",
        help="print out all possible matches",
        action="store_true"
    )
    args = parser.parse_args()
    elements = set(range(len(santdb)))
    pairs = (set(itertools.product(elements, elements)) -
        set(zip(elements, elements)) - bad_pairs)
    potential_matches = bijections_of(elements, pairs)

    if not potential_matches:
        print("No possible matches exist!")
    elif args.send:
        server = smtplib.SMTP(emaildb["Host"])
        server.starttls()
        server.login(emaildb["Username"], emaildb["Password"])

        for sa, se in sorted(random.choice(potential_matches)):
            send_email(sa, se, server)
            print(
                "{} has been sent their e-mail!".format(santdb[sa]["Name"])
            )

        server.quit()
        print("Done! Happy gift hunting!")
    elif args.potentials:
        for matches in potential_matches:
            for sa, se in matches:
                print(
                    "(Santa: \"{}\", Santee: \"{}\")".format(
                        santdb[sa]["Name"], santdb[se]["Name"]
                    )
                )

            print("-----")

        print(len(potential_matches), "possibilities in total")
    else:
        for sa, se in random.choice(potential_matches):
            print(
                "(Santa: \"{}\", Santee: \"{}\")".format(
                    santdb[sa]["Name"], santdb[se]["Name"]
                )
            )


if __name__ == "__main__":
    main()
